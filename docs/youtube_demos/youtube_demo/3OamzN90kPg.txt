Kind: captions
Language: en
Hey everyone, welcome back and let's
Hey everyone, welcome back and let's
Hey everyone, welcome back and let's
write some more neat code today. So
write some more neat code today. So
write some more neat code today. So
today, let's solve contains duplicate.
today, let's solve contains duplicate.
today, let's solve contains duplicate.
This is another problem from the blind
This is another problem from the blind
This is another problem from the blind
75 list of questions we've been working
75 list of questions we've been working
75 list of questions we've been working
on. So I like this problem because it's
on. So I like this problem because it's
on. So I like this problem because it's
a good problem for beginners, but
a good problem for beginners, but
a good problem for beginners, but
there's also multiple solutions to it
there's also multiple solutions to it
there's also multiple solutions to it
that I'd like to go over in this video.
that I'd like to go over in this video.
that I'd like to go over in this video.
So we're given an array of numbers. We
So we're given an array of numbers. We
So we're given an array of numbers. We
want to return true if there's any value
want to return true if there's any value
want to return true if there's any value
in that list of numbers that appears at
in that list of numbers that appears at
in that list of numbers that appears at
least twice, but maybe it could appear
least twice, but maybe it could appear
least twice, but maybe it could appear
three times or four times, right? just
three times or four times, right? just
three times or four times, right? just
at least twice and we want to return
at least twice and we want to return
at least twice and we want to return
false if there aren't any values that
false if there aren't any values that
false if there aren't any values that
appear at least twice. Basically what
appear at least twice. Basically what
appear at least twice. Basically what
that means is that every value in the
that means is that every value in the
that means is that every value in the
array is distinct. So let's take a look
array is distinct. So let's take a look
array is distinct. So let's take a look
at an example. We have 1 2 3 and then we
at an example. We have 1 2 3 and then we
at an example. We have 1 2 3 and then we
have one again. So of course this has
have one again. So of course this has
have one again. So of course this has
duplicates, right? So we return true.
duplicates, right? So we return true.
duplicates, right? So we return true.
And the easiest way we would be able to
And the easiest way we would be able to
And the easiest way we would be able to
detect that is by brute forcing this. So
detect that is by brute forcing this. So
detect that is by brute forcing this. So
given these numbers, the first thing we
given these numbers, the first thing we
given these numbers, the first thing we
do is look at the first number. It's
do is look at the first number. It's
do is look at the first number. It's
one. How do we know if this is a
one. How do we know if this is a
one. How do we know if this is a
duplicate or not? Well, we'd have to
duplicate or not? Well, we'd have to
duplicate or not? Well, we'd have to
compare it to every single number in the
compare it to every single number in the
compare it to every single number in the
rest of the array. So that would be a
rest of the array. So that would be a
rest of the array. So that would be a
big O of n time operation just to check
big O of n time operation just to check
big O of n time operation just to check
if the first number is a duplicate or
if the first number is a duplicate or
if the first number is a duplicate or
not. And then we'd have to do that for
not. And then we'd have to do that for
not. And then we'd have to do that for
every number. Then we have to check is
every number. Then we have to check is
every number. Then we have to check is
the second number a duplicate. How do we
the second number a duplicate. How do we
the second number a duplicate. How do we
know? We have to compare it to every
know? We have to compare it to every
know? We have to compare it to every
other number. We do the same thing with
other number. We do the same thing with
other number. We do the same thing with
the third one and the last one. And so
the third one and the last one. And so
the third one and the last one. And so
since we're doing it for every number in
since we're doing it for every number in
since we're doing it for every number in
the array, the overall time complexity
the array, the overall time complexity
the array, the overall time complexity
is going to become N squared. And by the
is going to become N squared. And by the
is going to become N squared. And by the
way, in this case, N is just the size of
way, in this case, N is just the size of
way, in this case, N is just the size of
the input array. So the brute force
the input array. So the brute force
the input array. So the brute force
solution is bigo N 2 time complexity.
solution is bigo N 2 time complexity.
solution is bigo N 2 time complexity.
But the good thing is we don't need any
But the good thing is we don't need any
But the good thing is we don't need any
extra memory. So the memory complexity
extra memory. So the memory complexity
extra memory. So the memory complexity
is bigo of 1. It's definitely not a bad
is bigo of 1. It's definitely not a bad
is bigo of 1. It's definitely not a bad
solution. But the question is, can we do
solution. But the question is, can we do
solution. But the question is, can we do
better than that? And yes, we definitely
better than that? And yes, we definitely
better than that? And yes, we definitely
can. A second approach that will help us
can. A second approach that will help us
can. A second approach that will help us
is sorting. What happens if we took this
is sorting. What happens if we took this
is sorting. What happens if we took this
array and we sorted it? It would look a
array and we sorted it? It would look a
array and we sorted it? It would look a
little bit different. It would look like
little bit different. It would look like
little bit different. It would look like
this. Okay, but how does sorting help
this. Okay, but how does sorting help
this. Okay, but how does sorting help
us? Well, let's think about it. If we
us? Well, let's think about it. If we
us? Well, let's think about it. If we
sort the input, then any duplicates that
sort the input, then any duplicates that
sort the input, then any duplicates that
do exist in the array, and clearly we
do exist in the array, and clearly we
do exist in the array, and clearly we
see that two duplicates exist at the
see that two duplicates exist at the
see that two duplicates exist at the
beginning of the array, they're going to
beginning of the array, they're going to
beginning of the array, they're going to
be adjacent. So when we're uh trying to
be adjacent. So when we're uh trying to
be adjacent. So when we're uh trying to
detect any duplicates in here, we only
detect any duplicates in here, we only
detect any duplicates in here, we only
have to iterate through the array once.
have to iterate through the array once.
have to iterate through the array once.
And as we do that, we're just going to
And as we do that, we're just going to
And as we do that, we're just going to
be comparing two neighbors in the array,
be comparing two neighbors in the array,
be comparing two neighbors in the array,
checking if they're duplicates. Next,
checking if they're duplicates. Next,
checking if they're duplicates. Next,
we're going to shift our pointers to the
we're going to shift our pointers to the
we're going to shift our pointers to the
next spot. Are these duplicates? Are
next spot. Are these duplicates? Are
next spot. Are these duplicates? Are
these duplicates? Etc., etc., until we
these duplicates? Etc., etc., until we
these duplicates? Etc., etc., until we
finish the entire array. In this case,
finish the entire array. In this case,
finish the entire array. In this case,
we see that these two adjacent values
we see that these two adjacent values
we see that these two adjacent values
are duplicates. So we can return true.
are duplicates. So we can return true.
are duplicates. So we can return true.
And what's the time complexity of this?
And what's the time complexity of this?
And what's the time complexity of this?
Well, the one pass is just going to be
Well, the one pass is just going to be
Well, the one pass is just going to be
big O of N. But we know that sorting
big O of N. But we know that sorting
big O of N. But we know that sorting
does take extra memory or not extra
does take extra memory or not extra
does take extra memory or not extra
memory, it does take uh extra time
memory, it does take uh extra time
memory, it does take uh extra time
complexity. And that time complexity is
complexity. And that time complexity is
complexity. And that time complexity is
N log N. So that's the bottleneck in
N log N. So that's the bottleneck in
N log N. So that's the bottleneck in
this solution. But again, we don't need
this solution. But again, we don't need
this solution. But again, we don't need
extra space if you don't count the space
extra space if you don't count the space
extra space if you don't count the space
that's used by the sorting algorithm. So
that's used by the sorting algorithm. So
that's used by the sorting algorithm. So
in this case, we do have a slightly
in this case, we do have a slightly
in this case, we do have a slightly
better solution than brute force. But
better solution than brute force. But
better solution than brute force. But
actually, if we use a little bit extra
actually, if we use a little bit extra
actually, if we use a little bit extra
memory, and it's really a tradeoff. If
memory, and it's really a tradeoff. If
memory, and it's really a tradeoff. If
we sacrifice space complexity, we can
we sacrifice space complexity, we can
we sacrifice space complexity, we can
actually achieve better memory
actually achieve better memory
actually achieve better memory
complexity. And let me show you how. So,
complexity. And let me show you how. So,
complexity. And let me show you how. So,
suppose we don't sort our input. We're
suppose we don't sort our input. We're
suppose we don't sort our input. We're
given the default input. But we use
given the default input. But we use
given the default input. But we use
extra memory. We use a hash set. But
extra memory. We use a hash set. But
extra memory. We use a hash set. But
what exactly is a hash set going to do
what exactly is a hash set going to do
what exactly is a hash set going to do
for us? It's going to allow us to insert
for us? It's going to allow us to insert
for us? It's going to allow us to insert
elements into the hash set in big O of
elements into the hash set in big O of
elements into the hash set in big O of
one time. But it's also going to allow
one time. But it's also going to allow
one time. But it's also going to allow
us to check. We can ask our hashmap,
us to check. We can ask our hashmap,
us to check. We can ask our hashmap,
does a certain value exist? We want to
does a certain value exist? We want to
does a certain value exist? We want to
know, does this one exist in the
know, does this one exist in the
know, does this one exist in the
hashmap? Well, if we start at the
hashmap? Well, if we start at the
hashmap? Well, if we start at the
beginning of the array, so far nothing
beginning of the array, so far nothing
beginning of the array, so far nothing
is in our hashmap. So, a one does not
is in our hashmap. So, a one does not
is in our hashmap. So, a one does not
exist in our hashmap. That means this
exist in our hashmap. That means this
exist in our hashmap. That means this
one is not a duplicate. You can see that
one is not a duplicate. You can see that
one is not a duplicate. You can see that
this is an improvement over the brute
this is an improvement over the brute
this is an improvement over the brute
force. Previously, to to determine if
force. Previously, to to determine if
force. Previously, to to determine if
this was a duplicate, we had to check
this was a duplicate, we had to check
this was a duplicate, we had to check
every other value in the array. This
every other value in the array. This
every other value in the array. This
time we don't. But after we have checked
time we don't. But after we have checked
time we don't. But after we have checked
if this is a duplicate, we do have to
if this is a duplicate, we do have to
if this is a duplicate, we do have to
add it to our hash set because later on
add it to our hash set because later on
add it to our hash set because later on
if we encounter a one like over here,
if we encounter a one like over here,
if we encounter a one like over here,
then we determine that this is a
then we determine that this is a
then we determine that this is a
duplicate because we know that there's
duplicate because we know that there's
duplicate because we know that there's
already a one in our hash set. So next
already a one in our hash set. So next
already a one in our hash set. So next
we're going to check two. Two is not a
we're going to check two. Two is not a
we're going to check two. Two is not a
duplicate. Add it here. Is three a
duplicate. Add it here. Is three a
duplicate. Add it here. Is three a
duplicate? Nope. Add it here. One. Is
duplicate? Nope. Add it here. One. Is
duplicate? Nope. Add it here. One. Is
this a duplicate? Yep, there's a one
this a duplicate? Yep, there's a one
this a duplicate? Yep, there's a one
over here. So we return true. This does
over here. So we return true. This does
over here. So we return true. This does
contain duplicates. And by the way,
contain duplicates. And by the way,
contain duplicates. And by the way,
since each operation was just big O of
since each operation was just big O of
since each operation was just big O of
one, we had to do that for every value
one, we had to do that for every value
one, we had to do that for every value
in the input array. And we only had to
in the input array. And we only had to
in the input array. And we only had to
scan through the list of inputs once.
scan through the list of inputs once.
scan through the list of inputs once.
The time complexity is going to be big O
The time complexity is going to be big O
The time complexity is going to be big O
of N. But the space complexity, we did
of N. But the space complexity, we did
of N. But the space complexity, we did
have to sacrifice a little bit. We have
have to sacrifice a little bit. We have
have to sacrifice a little bit. We have
to create a hash set and the memory that
to create a hash set and the memory that
to create a hash set and the memory that
that hash set will use could be up to
that hash set will use could be up to
that hash set will use could be up to
the size of the input array, which is n.
the size of the input array, which is n.
the size of the input array, which is n.
So we do end up using extra memory, but
So we do end up using extra memory, but
So we do end up using extra memory, but
that's not too bad. This is about as
that's not too bad. This is about as
that's not too bad. This is about as
efficient as we can get in terms of time
efficient as we can get in terms of time
efficient as we can get in terms of time
complexity. So let's get into the code
complexity. So let's get into the code
complexity. So let's get into the code
now. Okay. So now let's get into the
now. Okay. So now let's get into the
now. Okay. So now let's get into the
code. So the first thing I'm going to do
code. So the first thing I'm going to do
code. So the first thing I'm going to do
is create that hash set. In Python you
is create that hash set. In Python you
is create that hash set. In Python you
can do that just like this. It's just
can do that just like this. It's just
can do that just like this. It's just
called a set. And then the simple thing
called a set. And then the simple thing
called a set. And then the simple thing
is just going through every value in the
is just going through every value in the
is just going through every value in the
input array nums. And uh before we end
input array nums. And uh before we end
input array nums. And uh before we end
up adding it to our hash set because
up adding it to our hash set because
up adding it to our hash set because
remember we want to add every one of
remember we want to add every one of
remember we want to add every one of
these values to our hash set just like
these values to our hash set just like
these values to our hash set just like
this. But before we even do that, we
this. But before we even do that, we
this. But before we even do that, we
want to know is n a duplicate. Does this
want to know is n a duplicate. Does this
want to know is n a duplicate. Does this
value already exist in our hash set? And
value already exist in our hash set? And
value already exist in our hash set? And
if it does, we know that our array
if it does, we know that our array
if it does, we know that our array
contains duplicates. So we don't even
contains duplicates. So we don't even
contains duplicates. So we don't even
have to continue through the rest of the
have to continue through the rest of the
have to continue through the rest of the
array, we can immediately return true
array, we can immediately return true
array, we can immediately return true
because we found a duplicate. But if it
because we found a duplicate. But if it
because we found a duplicate. But if it
doesn't contain a duplicate, we're going
doesn't contain a duplicate, we're going
doesn't contain a duplicate, we're going
to add that value. Then iterate through
to add that value. Then iterate through
to add that value. Then iterate through
the rest of the array of nums. And then
the rest of the array of nums. And then
the rest of the array of nums. And then
the loop will exit. And then we can
the loop will exit. And then we can
the loop will exit. And then we can
return false to indicate that we did not
return false to indicate that we did not
return false to indicate that we did not
find any duplicates in the array. Now,
find any duplicates in the array. Now,
find any duplicates in the array. Now,
let's run the code to make sure that it
let's run the code to make sure that it
let's run the code to make sure that it
works. And on the left, you can see that
works. And on the left, you can see that
works. And on the left, you can see that
yes, it does work. And it is about as
yes, it does work. And it is about as
yes, it does work. And it is about as
efficient as we can get. So, I really
efficient as we can get. So, I really
efficient as we can get. So, I really
hope that this was helpful. If it was,
hope that this was helpful. If it was,
hope that this was helpful. If it was,
please like and subscribe. It supports
please like and subscribe. It supports
please like and subscribe. It supports
the channel a lot. consider checking out
the channel a lot. consider checking out
the channel a lot. consider checking out
my Patreon where you can further support
my Patreon where you can further support
my Patreon where you can further support
the channel and hopefully I'll see you
the channel and hopefully I'll see you
the channel and hopefully I'll see you
pretty soon.