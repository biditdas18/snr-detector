WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:01.750 align:start position:0%
 
Hey<00:00:00.240><c> everyone,</c><00:00:00.800><c> welcome</c><00:00:01.120><c> back</c><00:00:01.280><c> and</c><00:00:01.520><c> let's</c>

00:00:01.750 --> 00:00:01.760 align:start position:0%
Hey everyone, welcome back and let's
 

00:00:01.760 --> 00:00:03.270 align:start position:0%
Hey everyone, welcome back and let's
write<00:00:01.920><c> some</c><00:00:02.080><c> more</c><00:00:02.240><c> neat</c><00:00:02.560><c> code</c><00:00:02.800><c> today.</c><00:00:03.120><c> So</c>

00:00:03.270 --> 00:00:03.280 align:start position:0%
write some more neat code today. So
 

00:00:03.280 --> 00:00:05.829 align:start position:0%
write some more neat code today. So
today,<00:00:03.520><c> let's</c><00:00:03.760><c> solve</c><00:00:04.160><c> contains</c><00:00:04.880><c> duplicate.</c>

00:00:05.829 --> 00:00:05.839 align:start position:0%
today, let's solve contains duplicate.
 

00:00:05.839 --> 00:00:08.230 align:start position:0%
today, let's solve contains duplicate.
This<00:00:06.000><c> is</c><00:00:06.160><c> another</c><00:00:06.560><c> problem</c><00:00:07.040><c> from</c><00:00:07.359><c> the</c><00:00:07.759><c> blind</c>

00:00:08.230 --> 00:00:08.240 align:start position:0%
This is another problem from the blind
 

00:00:08.240 --> 00:00:10.070 align:start position:0%
This is another problem from the blind
75<00:00:08.720><c> list</c><00:00:08.960><c> of</c><00:00:09.120><c> questions</c><00:00:09.440><c> we've</c><00:00:09.760><c> been</c><00:00:09.920><c> working</c>

00:00:10.070 --> 00:00:10.080 align:start position:0%
75 list of questions we've been working
 

00:00:10.080 --> 00:00:12.310 align:start position:0%
75 list of questions we've been working
on.<00:00:10.480><c> So</c><00:00:10.639><c> I</c><00:00:10.800><c> like</c><00:00:10.960><c> this</c><00:00:11.200><c> problem</c><00:00:11.679><c> because</c><00:00:12.080><c> it's</c>

00:00:12.310 --> 00:00:12.320 align:start position:0%
on. So I like this problem because it's
 

00:00:12.320 --> 00:00:14.070 align:start position:0%
on. So I like this problem because it's
a<00:00:12.480><c> good</c><00:00:12.639><c> problem</c><00:00:12.960><c> for</c><00:00:13.200><c> beginners,</c><00:00:13.840><c> but</c>

00:00:14.070 --> 00:00:14.080 align:start position:0%
a good problem for beginners, but
 

00:00:14.080 --> 00:00:15.910 align:start position:0%
a good problem for beginners, but
there's<00:00:14.320><c> also</c><00:00:14.639><c> multiple</c><00:00:15.200><c> solutions</c><00:00:15.599><c> to</c><00:00:15.759><c> it</c>

00:00:15.910 --> 00:00:15.920 align:start position:0%
there's also multiple solutions to it
 

00:00:15.920 --> 00:00:17.830 align:start position:0%
there's also multiple solutions to it
that<00:00:16.080><c> I'd</c><00:00:16.320><c> like</c><00:00:16.480><c> to</c><00:00:16.640><c> go</c><00:00:16.800><c> over</c><00:00:17.039><c> in</c><00:00:17.359><c> this</c><00:00:17.520><c> video.</c>

00:00:17.830 --> 00:00:17.840 align:start position:0%
that I'd like to go over in this video.
 

00:00:17.840 --> 00:00:20.390 align:start position:0%
that I'd like to go over in this video.
So<00:00:18.080><c> we're</c><00:00:18.240><c> given</c><00:00:18.480><c> an</c><00:00:18.720><c> array</c><00:00:19.039><c> of</c><00:00:19.439><c> numbers.</c><00:00:20.240><c> We</c>

00:00:20.390 --> 00:00:20.400 align:start position:0%
So we're given an array of numbers. We
 

00:00:20.400 --> 00:00:22.630 align:start position:0%
So we're given an array of numbers. We
want<00:00:20.480><c> to</c><00:00:20.640><c> return</c><00:00:20.960><c> true</c><00:00:21.279><c> if</c><00:00:21.520><c> there's</c><00:00:21.840><c> any</c><00:00:22.240><c> value</c>

00:00:22.630 --> 00:00:22.640 align:start position:0%
want to return true if there's any value
 

00:00:22.640 --> 00:00:25.189 align:start position:0%
want to return true if there's any value
in<00:00:22.960><c> that</c><00:00:23.199><c> list</c><00:00:23.359><c> of</c><00:00:23.600><c> numbers</c><00:00:23.920><c> that</c><00:00:24.240><c> appears</c><00:00:24.880><c> at</c>

00:00:25.189 --> 00:00:25.199 align:start position:0%
in that list of numbers that appears at
 

00:00:25.199 --> 00:00:27.349 align:start position:0%
in that list of numbers that appears at
least<00:00:25.760><c> twice,</c><00:00:26.240><c> but</c><00:00:26.480><c> maybe</c><00:00:26.720><c> it</c><00:00:26.880><c> could</c><00:00:27.039><c> appear</c>

00:00:27.349 --> 00:00:27.359 align:start position:0%
least twice, but maybe it could appear
 

00:00:27.359 --> 00:00:29.429 align:start position:0%
least twice, but maybe it could appear
three<00:00:27.599><c> times</c><00:00:27.840><c> or</c><00:00:28.160><c> four</c><00:00:28.400><c> times,</c><00:00:28.880><c> right?</c><00:00:29.199><c> just</c>

00:00:29.429 --> 00:00:29.439 align:start position:0%
three times or four times, right? just
 

00:00:29.439 --> 00:00:31.830 align:start position:0%
three times or four times, right? just
at<00:00:29.519><c> least</c><00:00:29.920><c> twice</c><00:00:30.800><c> and</c><00:00:31.039><c> we</c><00:00:31.199><c> want</c><00:00:31.359><c> to</c><00:00:31.519><c> return</c>

00:00:31.830 --> 00:00:31.840 align:start position:0%
at least twice and we want to return
 

00:00:31.840 --> 00:00:34.310 align:start position:0%
at least twice and we want to return
false<00:00:32.399><c> if</c><00:00:32.800><c> there</c><00:00:33.040><c> aren't</c><00:00:33.440><c> any</c><00:00:33.680><c> values</c><00:00:34.079><c> that</c>

00:00:34.310 --> 00:00:34.320 align:start position:0%
false if there aren't any values that
 

00:00:34.320 --> 00:00:36.389 align:start position:0%
false if there aren't any values that
appear<00:00:34.880><c> at</c><00:00:35.040><c> least</c><00:00:35.360><c> twice.</c><00:00:35.840><c> Basically</c><00:00:36.239><c> what</c>

00:00:36.389 --> 00:00:36.399 align:start position:0%
appear at least twice. Basically what
 

00:00:36.399 --> 00:00:38.549 align:start position:0%
appear at least twice. Basically what
that<00:00:36.640><c> means</c><00:00:36.800><c> is</c><00:00:37.040><c> that</c><00:00:37.280><c> every</c><00:00:37.520><c> value</c><00:00:37.920><c> in</c><00:00:38.239><c> the</c>

00:00:38.549 --> 00:00:38.559 align:start position:0%
that means is that every value in the
 

00:00:38.559 --> 00:00:41.030 align:start position:0%
that means is that every value in the
array<00:00:38.879><c> is</c><00:00:39.280><c> distinct.</c><00:00:40.320><c> So</c><00:00:40.480><c> let's</c><00:00:40.719><c> take</c><00:00:40.800><c> a</c><00:00:40.960><c> look</c>

00:00:41.030 --> 00:00:41.040 align:start position:0%
array is distinct. So let's take a look
 

00:00:41.040 --> 00:00:43.910 align:start position:0%
array is distinct. So let's take a look
at<00:00:41.200><c> an</c><00:00:41.280><c> example.</c><00:00:41.680><c> We</c><00:00:41.840><c> have</c><00:00:42.000><c> 1</c><00:00:42.239><c> 2</c><00:00:42.559><c> 3</c><00:00:43.200><c> and</c><00:00:43.440><c> then</c><00:00:43.680><c> we</c>

00:00:43.910 --> 00:00:43.920 align:start position:0%
at an example. We have 1 2 3 and then we
 

00:00:43.920 --> 00:00:46.630 align:start position:0%
at an example. We have 1 2 3 and then we
have<00:00:44.160><c> one</c><00:00:44.719><c> again.</c><00:00:45.440><c> So</c><00:00:45.680><c> of</c><00:00:45.920><c> course</c><00:00:46.160><c> this</c><00:00:46.399><c> has</c>

00:00:46.630 --> 00:00:46.640 align:start position:0%
have one again. So of course this has
 

00:00:46.640 --> 00:00:49.510 align:start position:0%
have one again. So of course this has
duplicates,<00:00:47.200><c> right?</c><00:00:47.520><c> So</c><00:00:47.840><c> we</c><00:00:48.160><c> return</c><00:00:48.640><c> true.</c>

00:00:49.510 --> 00:00:49.520 align:start position:0%
duplicates, right? So we return true.
 

00:00:49.520 --> 00:00:51.750 align:start position:0%
duplicates, right? So we return true.
And<00:00:49.840><c> the</c><00:00:50.160><c> easiest</c><00:00:50.559><c> way</c><00:00:50.719><c> we</c><00:00:50.960><c> would</c><00:00:51.120><c> be</c><00:00:51.280><c> able</c><00:00:51.440><c> to</c>

00:00:51.750 --> 00:00:51.760 align:start position:0%
And the easiest way we would be able to
 

00:00:51.760 --> 00:00:55.189 align:start position:0%
And the easiest way we would be able to
detect<00:00:52.160><c> that</c><00:00:52.800><c> is</c><00:00:53.280><c> by</c><00:00:53.680><c> brute</c><00:00:54.000><c> forcing</c><00:00:54.399><c> this.</c><00:00:54.800><c> So</c>

00:00:55.189 --> 00:00:55.199 align:start position:0%
detect that is by brute forcing this. So
 

00:00:55.199 --> 00:00:58.069 align:start position:0%
detect that is by brute forcing this. So
given<00:00:55.760><c> these</c><00:00:56.320><c> numbers,</c><00:00:57.280><c> the</c><00:00:57.520><c> first</c><00:00:57.680><c> thing</c><00:00:57.840><c> we</c>

00:00:58.069 --> 00:00:58.079 align:start position:0%
given these numbers, the first thing we
 

00:00:58.079 --> 00:01:00.310 align:start position:0%
given these numbers, the first thing we
do<00:00:58.239><c> is</c><00:00:58.480><c> look</c><00:00:58.640><c> at</c><00:00:58.800><c> the</c><00:00:59.039><c> first</c><00:00:59.520><c> number.</c><00:01:00.000><c> It's</c>

00:01:00.310 --> 00:01:00.320 align:start position:0%
do is look at the first number. It's
 

00:01:00.320 --> 00:01:02.150 align:start position:0%
do is look at the first number. It's
one.<00:01:00.800><c> How</c><00:01:01.039><c> do</c><00:01:01.120><c> we</c><00:01:01.280><c> know</c><00:01:01.440><c> if</c><00:01:01.600><c> this</c><00:01:01.840><c> is</c><00:01:01.920><c> a</c>

00:01:02.150 --> 00:01:02.160 align:start position:0%
one. How do we know if this is a
 

00:01:02.160 --> 00:01:04.149 align:start position:0%
one. How do we know if this is a
duplicate<00:01:02.640><c> or</c><00:01:02.960><c> not?</c><00:01:03.440><c> Well,</c><00:01:03.600><c> we'd</c><00:01:03.920><c> have</c><00:01:04.000><c> to</c>

00:01:04.149 --> 00:01:04.159 align:start position:0%
duplicate or not? Well, we'd have to
 

00:01:04.159 --> 00:01:07.670 align:start position:0%
duplicate or not? Well, we'd have to
compare<00:01:04.479><c> it</c><00:01:04.640><c> to</c><00:01:05.040><c> every</c><00:01:05.519><c> single</c><00:01:06.000><c> number</c><00:01:06.720><c> in</c><00:01:07.360><c> the</c>

00:01:07.670 --> 00:01:07.680 align:start position:0%
compare it to every single number in the
 

00:01:07.680 --> 00:01:10.550 align:start position:0%
compare it to every single number in the
rest<00:01:08.000><c> of</c><00:01:08.240><c> the</c><00:01:08.560><c> array.</c><00:01:09.040><c> So</c><00:01:09.200><c> that</c><00:01:09.520><c> would</c><00:01:09.760><c> be</c><00:01:10.320><c> a</c>

00:01:10.550 --> 00:01:10.560 align:start position:0%
rest of the array. So that would be a
 

00:01:10.560 --> 00:01:13.429 align:start position:0%
rest of the array. So that would be a
big<00:01:10.880><c> O</c><00:01:11.119><c> of</c><00:01:11.439><c> n</c><00:01:11.920><c> time</c><00:01:12.159><c> operation</c><00:01:12.799><c> just</c><00:01:13.040><c> to</c><00:01:13.200><c> check</c>

00:01:13.429 --> 00:01:13.439 align:start position:0%
big O of n time operation just to check
 

00:01:13.439 --> 00:01:15.830 align:start position:0%
big O of n time operation just to check
if<00:01:13.680><c> the</c><00:01:13.920><c> first</c><00:01:14.320><c> number</c><00:01:14.640><c> is</c><00:01:14.880><c> a</c><00:01:15.040><c> duplicate</c><00:01:15.600><c> or</c>

00:01:15.830 --> 00:01:15.840 align:start position:0%
if the first number is a duplicate or
 

00:01:15.840 --> 00:01:17.749 align:start position:0%
if the first number is a duplicate or
not.<00:01:16.240><c> And</c><00:01:16.400><c> then</c><00:01:16.640><c> we'd</c><00:01:16.960><c> have</c><00:01:17.040><c> to</c><00:01:17.200><c> do</c><00:01:17.280><c> that</c><00:01:17.520><c> for</c>

00:01:17.749 --> 00:01:17.759 align:start position:0%
not. And then we'd have to do that for
 

00:01:17.759 --> 00:01:19.749 align:start position:0%
not. And then we'd have to do that for
every<00:01:18.080><c> number.</c><00:01:18.560><c> Then</c><00:01:18.799><c> we</c><00:01:18.960><c> have</c><00:01:19.040><c> to</c><00:01:19.200><c> check</c><00:01:19.520><c> is</c>

00:01:19.749 --> 00:01:19.759 align:start position:0%
every number. Then we have to check is
 

00:01:19.759 --> 00:01:21.429 align:start position:0%
every number. Then we have to check is
the<00:01:19.920><c> second</c><00:01:20.159><c> number</c><00:01:20.320><c> a</c><00:01:20.560><c> duplicate.</c><00:01:21.040><c> How</c><00:01:21.200><c> do</c><00:01:21.280><c> we</c>

00:01:21.429 --> 00:01:21.439 align:start position:0%
the second number a duplicate. How do we
 

00:01:21.439 --> 00:01:23.270 align:start position:0%
the second number a duplicate. How do we
know?<00:01:21.680><c> We</c><00:01:21.840><c> have</c><00:01:21.920><c> to</c><00:01:22.080><c> compare</c><00:01:22.320><c> it</c><00:01:22.640><c> to</c><00:01:22.960><c> every</c>

00:01:23.270 --> 00:01:23.280 align:start position:0%
know? We have to compare it to every
 

00:01:23.280 --> 00:01:25.510 align:start position:0%
know? We have to compare it to every
other<00:01:23.600><c> number.</c><00:01:24.400><c> We</c><00:01:24.640><c> do</c><00:01:24.799><c> the</c><00:01:25.040><c> same</c><00:01:25.119><c> thing</c><00:01:25.280><c> with</c>

00:01:25.510 --> 00:01:25.520 align:start position:0%
other number. We do the same thing with
 

00:01:25.520 --> 00:01:28.710 align:start position:0%
other number. We do the same thing with
the<00:01:25.680><c> third</c><00:01:25.920><c> one</c><00:01:26.320><c> and</c><00:01:26.720><c> the</c><00:01:26.960><c> last</c><00:01:27.280><c> one.</c><00:01:28.080><c> And</c><00:01:28.479><c> so</c>

00:01:28.710 --> 00:01:28.720 align:start position:0%
the third one and the last one. And so
 

00:01:28.720 --> 00:01:30.390 align:start position:0%
the third one and the last one. And so
since<00:01:28.960><c> we're</c><00:01:29.200><c> doing</c><00:01:29.280><c> it</c><00:01:29.520><c> for</c><00:01:29.680><c> every</c><00:01:29.920><c> number</c><00:01:30.159><c> in</c>

00:01:30.390 --> 00:01:30.400 align:start position:0%
since we're doing it for every number in
 

00:01:30.400 --> 00:01:32.069 align:start position:0%
since we're doing it for every number in
the<00:01:30.560><c> array,</c><00:01:30.799><c> the</c><00:01:31.040><c> overall</c><00:01:31.360><c> time</c><00:01:31.600><c> complexity</c>

00:01:32.069 --> 00:01:32.079 align:start position:0%
the array, the overall time complexity
 

00:01:32.079 --> 00:01:34.550 align:start position:0%
the array, the overall time complexity
is<00:01:32.240><c> going</c><00:01:32.320><c> to</c><00:01:32.479><c> become</c><00:01:32.880><c> N</c><00:01:33.360><c> squared.</c><00:01:34.079><c> And</c><00:01:34.240><c> by</c><00:01:34.400><c> the</c>

00:01:34.550 --> 00:01:34.560 align:start position:0%
is going to become N squared. And by the
 

00:01:34.560 --> 00:01:37.590 align:start position:0%
is going to become N squared. And by the
way,<00:01:34.720><c> in</c><00:01:34.880><c> this</c><00:01:35.040><c> case,</c><00:01:35.439><c> N</c><00:01:35.759><c> is</c><00:01:36.079><c> just</c><00:01:36.400><c> the</c><00:01:36.720><c> size</c><00:01:37.200><c> of</c>

00:01:37.590 --> 00:01:37.600 align:start position:0%
way, in this case, N is just the size of
 

00:01:37.600 --> 00:01:40.149 align:start position:0%
way, in this case, N is just the size of
the<00:01:37.920><c> input</c><00:01:38.400><c> array.</c><00:01:39.280><c> So</c><00:01:39.360><c> the</c><00:01:39.600><c> brute</c><00:01:39.840><c> force</c>

00:01:40.149 --> 00:01:40.159 align:start position:0%
the input array. So the brute force
 

00:01:40.159 --> 00:01:43.350 align:start position:0%
the input array. So the brute force
solution<00:01:40.560><c> is</c><00:01:40.799><c> bigo</c><00:01:41.360><c> N</c><00:01:41.840><c> 2</c><00:01:42.240><c> time</c><00:01:42.560><c> complexity.</c>

00:01:43.350 --> 00:01:43.360 align:start position:0%
solution is bigo N 2 time complexity.
 

00:01:43.360 --> 00:01:44.950 align:start position:0%
solution is bigo N 2 time complexity.
But<00:01:43.520><c> the</c><00:01:43.680><c> good</c><00:01:43.840><c> thing</c><00:01:44.000><c> is</c><00:01:44.159><c> we</c><00:01:44.400><c> don't</c><00:01:44.560><c> need</c><00:01:44.720><c> any</c>

00:01:44.950 --> 00:01:44.960 align:start position:0%
But the good thing is we don't need any
 

00:01:44.960 --> 00:01:47.109 align:start position:0%
But the good thing is we don't need any
extra<00:01:45.360><c> memory.</c><00:01:45.920><c> So</c><00:01:46.000><c> the</c><00:01:46.240><c> memory</c><00:01:46.560><c> complexity</c>

00:01:47.109 --> 00:01:47.119 align:start position:0%
extra memory. So the memory complexity
 

00:01:47.119 --> 00:01:50.310 align:start position:0%
extra memory. So the memory complexity
is<00:01:47.520><c> bigo</c><00:01:47.920><c> of</c><00:01:48.079><c> 1.</c><00:01:48.799><c> It's</c><00:01:49.040><c> definitely</c><00:01:49.600><c> not</c><00:01:49.840><c> a</c><00:01:50.079><c> bad</c>

00:01:50.310 --> 00:01:50.320 align:start position:0%
is bigo of 1. It's definitely not a bad
 

00:01:50.320 --> 00:01:52.710 align:start position:0%
is bigo of 1. It's definitely not a bad
solution.<00:01:50.880><c> But</c><00:01:50.960><c> the</c><00:01:51.200><c> question</c><00:01:51.439><c> is,</c><00:01:52.000><c> can</c><00:01:52.240><c> we</c><00:01:52.479><c> do</c>

00:01:52.710 --> 00:01:52.720 align:start position:0%
solution. But the question is, can we do
 

00:01:52.720 --> 00:01:54.710 align:start position:0%
solution. But the question is, can we do
better<00:01:52.960><c> than</c><00:01:53.200><c> that?</c><00:01:53.600><c> And</c><00:01:53.840><c> yes,</c><00:01:54.079><c> we</c><00:01:54.320><c> definitely</c>

00:01:54.710 --> 00:01:54.720 align:start position:0%
better than that? And yes, we definitely
 

00:01:54.720 --> 00:01:57.590 align:start position:0%
better than that? And yes, we definitely
can.<00:01:55.520><c> A</c><00:01:55.840><c> second</c><00:01:56.079><c> approach</c><00:01:56.720><c> that</c><00:01:56.960><c> will</c><00:01:57.200><c> help</c><00:01:57.360><c> us</c>

00:01:57.590 --> 00:01:57.600 align:start position:0%
can. A second approach that will help us
 

00:01:57.600 --> 00:02:00.310 align:start position:0%
can. A second approach that will help us
is<00:01:58.159><c> sorting.</c><00:01:58.960><c> What</c><00:01:59.200><c> happens</c><00:01:59.520><c> if</c><00:01:59.680><c> we</c><00:01:59.840><c> took</c><00:02:00.079><c> this</c>

00:02:00.310 --> 00:02:00.320 align:start position:0%
is sorting. What happens if we took this
 

00:02:00.320 --> 00:02:02.709 align:start position:0%
is sorting. What happens if we took this
array<00:02:00.719><c> and</c><00:02:00.960><c> we</c><00:02:01.119><c> sorted</c><00:02:01.520><c> it?</c><00:02:01.920><c> It</c><00:02:02.079><c> would</c><00:02:02.240><c> look</c><00:02:02.479><c> a</c>

00:02:02.709 --> 00:02:02.719 align:start position:0%
array and we sorted it? It would look a
 

00:02:02.719 --> 00:02:04.310 align:start position:0%
array and we sorted it? It would look a
little<00:02:02.799><c> bit</c><00:02:03.040><c> different.</c><00:02:03.360><c> It</c><00:02:03.600><c> would</c><00:02:03.759><c> look</c><00:02:03.920><c> like</c>

00:02:04.310 --> 00:02:04.320 align:start position:0%
little bit different. It would look like
 

00:02:04.320 --> 00:02:07.350 align:start position:0%
little bit different. It would look like
this.<00:02:05.280><c> Okay,</c><00:02:05.759><c> but</c><00:02:06.000><c> how</c><00:02:06.240><c> does</c><00:02:06.479><c> sorting</c><00:02:07.119><c> help</c>

00:02:07.350 --> 00:02:07.360 align:start position:0%
this. Okay, but how does sorting help
 

00:02:07.360 --> 00:02:09.990 align:start position:0%
this. Okay, but how does sorting help
us?<00:02:07.920><c> Well,</c><00:02:08.239><c> let's</c><00:02:08.479><c> think</c><00:02:08.720><c> about</c><00:02:08.879><c> it.</c><00:02:09.520><c> If</c><00:02:09.759><c> we</c>

00:02:09.990 --> 00:02:10.000 align:start position:0%
us? Well, let's think about it. If we
 

00:02:10.000 --> 00:02:13.110 align:start position:0%
us? Well, let's think about it. If we
sort<00:02:10.479><c> the</c><00:02:10.800><c> input,</c><00:02:11.440><c> then</c><00:02:11.760><c> any</c><00:02:12.160><c> duplicates</c><00:02:12.800><c> that</c>

00:02:13.110 --> 00:02:13.120 align:start position:0%
sort the input, then any duplicates that
 

00:02:13.120 --> 00:02:15.430 align:start position:0%
sort the input, then any duplicates that
do<00:02:13.440><c> exist</c><00:02:13.840><c> in</c><00:02:14.080><c> the</c><00:02:14.239><c> array,</c><00:02:14.640><c> and</c><00:02:14.879><c> clearly</c><00:02:15.200><c> we</c>

00:02:15.430 --> 00:02:15.440 align:start position:0%
do exist in the array, and clearly we
 

00:02:15.440 --> 00:02:17.350 align:start position:0%
do exist in the array, and clearly we
see<00:02:15.599><c> that</c><00:02:15.840><c> two</c><00:02:16.080><c> duplicates</c><00:02:16.640><c> exist</c><00:02:16.959><c> at</c><00:02:17.200><c> the</c>

00:02:17.350 --> 00:02:17.360 align:start position:0%
see that two duplicates exist at the
 

00:02:17.360 --> 00:02:18.790 align:start position:0%
see that two duplicates exist at the
beginning<00:02:17.520><c> of</c><00:02:17.680><c> the</c><00:02:17.840><c> array,</c><00:02:18.319><c> they're</c><00:02:18.560><c> going</c><00:02:18.640><c> to</c>

00:02:18.790 --> 00:02:18.800 align:start position:0%
beginning of the array, they're going to
 

00:02:18.800 --> 00:02:21.670 align:start position:0%
beginning of the array, they're going to
be<00:02:19.120><c> adjacent.</c><00:02:19.920><c> So</c><00:02:20.239><c> when</c><00:02:20.400><c> we're</c><00:02:21.040><c> uh</c><00:02:21.280><c> trying</c><00:02:21.440><c> to</c>

00:02:21.670 --> 00:02:21.680 align:start position:0%
be adjacent. So when we're uh trying to
 

00:02:21.680 --> 00:02:23.990 align:start position:0%
be adjacent. So when we're uh trying to
detect<00:02:22.160><c> any</c><00:02:22.480><c> duplicates</c><00:02:23.040><c> in</c><00:02:23.280><c> here,</c><00:02:23.520><c> we</c><00:02:23.760><c> only</c>

00:02:23.990 --> 00:02:24.000 align:start position:0%
detect any duplicates in here, we only
 

00:02:24.000 --> 00:02:26.309 align:start position:0%
detect any duplicates in here, we only
have<00:02:24.080><c> to</c><00:02:24.239><c> iterate</c><00:02:24.720><c> through</c><00:02:24.959><c> the</c><00:02:25.120><c> array</c><00:02:25.599><c> once.</c>

00:02:26.309 --> 00:02:26.319 align:start position:0%
have to iterate through the array once.
 

00:02:26.319 --> 00:02:27.910 align:start position:0%
have to iterate through the array once.
And<00:02:26.640><c> as</c><00:02:26.959><c> we</c><00:02:27.120><c> do</c><00:02:27.200><c> that,</c><00:02:27.440><c> we're</c><00:02:27.599><c> just</c><00:02:27.760><c> going</c><00:02:27.840><c> to</c>

00:02:27.910 --> 00:02:27.920 align:start position:0%
And as we do that, we're just going to
 

00:02:27.920 --> 00:02:32.070 align:start position:0%
And as we do that, we're just going to
be<00:02:28.160><c> comparing</c><00:02:29.040><c> two</c><00:02:29.599><c> neighbors</c><00:02:30.480><c> in</c><00:02:30.959><c> the</c><00:02:31.520><c> array,</c>

00:02:32.070 --> 00:02:32.080 align:start position:0%
be comparing two neighbors in the array,
 

00:02:32.080 --> 00:02:33.990 align:start position:0%
be comparing two neighbors in the array,
checking<00:02:32.400><c> if</c><00:02:32.560><c> they're</c><00:02:32.800><c> duplicates.</c><00:02:33.519><c> Next,</c>

00:02:33.990 --> 00:02:34.000 align:start position:0%
checking if they're duplicates. Next,
 

00:02:34.000 --> 00:02:35.750 align:start position:0%
checking if they're duplicates. Next,
we're<00:02:34.239><c> going</c><00:02:34.319><c> to</c><00:02:34.400><c> shift</c><00:02:34.640><c> our</c><00:02:34.879><c> pointers</c><00:02:35.360><c> to</c><00:02:35.599><c> the</c>

00:02:35.750 --> 00:02:35.760 align:start position:0%
we're going to shift our pointers to the
 

00:02:35.760 --> 00:02:37.990 align:start position:0%
we're going to shift our pointers to the
next<00:02:35.920><c> spot.</c><00:02:36.400><c> Are</c><00:02:36.640><c> these</c><00:02:36.879><c> duplicates?</c><00:02:37.760><c> Are</c>

00:02:37.990 --> 00:02:38.000 align:start position:0%
next spot. Are these duplicates? Are
 

00:02:38.000 --> 00:02:40.229 align:start position:0%
next spot. Are these duplicates? Are
these<00:02:38.239><c> duplicates?</c><00:02:39.040><c> Etc.,</c><00:02:39.519><c> etc.,</c><00:02:39.760><c> until</c><00:02:40.000><c> we</c>

00:02:40.229 --> 00:02:40.239 align:start position:0%
these duplicates? Etc., etc., until we
 

00:02:40.239 --> 00:02:41.830 align:start position:0%
these duplicates? Etc., etc., until we
finish<00:02:40.400><c> the</c><00:02:40.640><c> entire</c><00:02:40.959><c> array.</c><00:02:41.360><c> In</c><00:02:41.519><c> this</c><00:02:41.599><c> case,</c>

00:02:41.830 --> 00:02:41.840 align:start position:0%
finish the entire array. In this case,
 

00:02:41.840 --> 00:02:43.830 align:start position:0%
finish the entire array. In this case,
we<00:02:42.080><c> see</c><00:02:42.160><c> that</c><00:02:42.400><c> these</c><00:02:42.720><c> two</c><00:02:42.879><c> adjacent</c><00:02:43.440><c> values</c>

00:02:43.830 --> 00:02:43.840 align:start position:0%
we see that these two adjacent values
 

00:02:43.840 --> 00:02:46.949 align:start position:0%
we see that these two adjacent values
are<00:02:44.080><c> duplicates.</c><00:02:45.120><c> So</c><00:02:45.599><c> we</c><00:02:45.840><c> can</c><00:02:46.000><c> return</c><00:02:46.319><c> true.</c>

00:02:46.949 --> 00:02:46.959 align:start position:0%
are duplicates. So we can return true.
 

00:02:46.959 --> 00:02:48.710 align:start position:0%
are duplicates. So we can return true.
And<00:02:47.120><c> what's</c><00:02:47.360><c> the</c><00:02:47.519><c> time</c><00:02:47.760><c> complexity</c><00:02:48.160><c> of</c><00:02:48.319><c> this?</c>

00:02:48.710 --> 00:02:48.720 align:start position:0%
And what's the time complexity of this?
 

00:02:48.720 --> 00:02:50.630 align:start position:0%
And what's the time complexity of this?
Well,<00:02:49.040><c> the</c><00:02:49.360><c> one</c><00:02:49.599><c> pass</c><00:02:49.920><c> is</c><00:02:50.160><c> just</c><00:02:50.319><c> going</c><00:02:50.400><c> to</c><00:02:50.480><c> be</c>

00:02:50.630 --> 00:02:50.640 align:start position:0%
Well, the one pass is just going to be
 

00:02:50.640 --> 00:02:52.790 align:start position:0%
Well, the one pass is just going to be
big<00:02:50.879><c> O</c><00:02:51.040><c> of</c><00:02:51.200><c> N.</c><00:02:51.519><c> But</c><00:02:51.680><c> we</c><00:02:51.920><c> know</c><00:02:52.000><c> that</c><00:02:52.239><c> sorting</c>

00:02:52.790 --> 00:02:52.800 align:start position:0%
big O of N. But we know that sorting
 

00:02:52.800 --> 00:02:54.949 align:start position:0%
big O of N. But we know that sorting
does<00:02:53.120><c> take</c><00:02:53.360><c> extra</c><00:02:53.760><c> memory</c><00:02:54.319><c> or</c><00:02:54.560><c> not</c><00:02:54.720><c> extra</c>

00:02:54.949 --> 00:02:54.959 align:start position:0%
does take extra memory or not extra
 

00:02:54.959 --> 00:02:56.949 align:start position:0%
does take extra memory or not extra
memory,<00:02:55.280><c> it</c><00:02:55.519><c> does</c><00:02:55.680><c> take</c><00:02:56.239><c> uh</c><00:02:56.400><c> extra</c><00:02:56.720><c> time</c>

00:02:56.949 --> 00:02:56.959 align:start position:0%
memory, it does take uh extra time
 

00:02:56.959 --> 00:02:58.630 align:start position:0%
memory, it does take uh extra time
complexity.<00:02:57.440><c> And</c><00:02:57.599><c> that</c><00:02:57.760><c> time</c><00:02:57.920><c> complexity</c><00:02:58.400><c> is</c>

00:02:58.630 --> 00:02:58.640 align:start position:0%
complexity. And that time complexity is
 

00:02:58.640 --> 00:03:01.430 align:start position:0%
complexity. And that time complexity is
N<00:02:59.200><c> log</c><00:02:59.760><c> N.</c><00:03:00.080><c> So</c><00:03:00.239><c> that's</c><00:03:00.480><c> the</c><00:03:00.720><c> bottleneck</c><00:03:01.200><c> in</c>

00:03:01.430 --> 00:03:01.440 align:start position:0%
N log N. So that's the bottleneck in
 

00:03:01.440 --> 00:03:04.070 align:start position:0%
N log N. So that's the bottleneck in
this<00:03:01.680><c> solution.</c><00:03:02.480><c> But</c><00:03:02.720><c> again,</c><00:03:03.120><c> we</c><00:03:03.440><c> don't</c><00:03:03.680><c> need</c>

00:03:04.070 --> 00:03:04.080 align:start position:0%
this solution. But again, we don't need
 

00:03:04.080 --> 00:03:06.550 align:start position:0%
this solution. But again, we don't need
extra<00:03:04.560><c> space</c><00:03:04.959><c> if</c><00:03:05.280><c> you</c><00:03:05.440><c> don't</c><00:03:05.599><c> count</c><00:03:06.000><c> the</c><00:03:06.319><c> space</c>

00:03:06.550 --> 00:03:06.560 align:start position:0%
extra space if you don't count the space
 

00:03:06.560 --> 00:03:09.670 align:start position:0%
extra space if you don't count the space
that's<00:03:06.959><c> used</c><00:03:07.280><c> by</c><00:03:07.519><c> the</c><00:03:07.760><c> sorting</c><00:03:08.159><c> algorithm.</c><00:03:09.200><c> So</c>

00:03:09.670 --> 00:03:09.680 align:start position:0%
that's used by the sorting algorithm. So
 

00:03:09.680 --> 00:03:11.910 align:start position:0%
that's used by the sorting algorithm. So
in<00:03:09.920><c> this</c><00:03:10.080><c> case,</c><00:03:10.560><c> we</c><00:03:10.879><c> do</c><00:03:11.040><c> have</c><00:03:11.200><c> a</c><00:03:11.519><c> slightly</c>

00:03:11.910 --> 00:03:11.920 align:start position:0%
in this case, we do have a slightly
 

00:03:11.920 --> 00:03:14.550 align:start position:0%
in this case, we do have a slightly
better<00:03:12.319><c> solution</c><00:03:12.879><c> than</c><00:03:13.360><c> brute</c><00:03:13.680><c> force.</c><00:03:14.319><c> But</c>

00:03:14.550 --> 00:03:14.560 align:start position:0%
better solution than brute force. But
 

00:03:14.560 --> 00:03:17.430 align:start position:0%
better solution than brute force. But
actually,<00:03:15.200><c> if</c><00:03:15.760><c> we</c><00:03:16.159><c> use</c><00:03:16.480><c> a</c><00:03:16.720><c> little</c><00:03:16.879><c> bit</c><00:03:17.040><c> extra</c>

00:03:17.430 --> 00:03:17.440 align:start position:0%
actually, if we use a little bit extra
 

00:03:17.440 --> 00:03:19.910 align:start position:0%
actually, if we use a little bit extra
memory,<00:03:18.000><c> and</c><00:03:18.159><c> it's</c><00:03:18.480><c> really</c><00:03:18.640><c> a</c><00:03:18.879><c> tradeoff.</c><00:03:19.680><c> If</c>

00:03:19.910 --> 00:03:19.920 align:start position:0%
memory, and it's really a tradeoff. If
 

00:03:19.920 --> 00:03:22.630 align:start position:0%
memory, and it's really a tradeoff. If
we<00:03:20.319><c> sacrifice</c><00:03:21.040><c> space</c><00:03:21.440><c> complexity,</c><00:03:22.159><c> we</c><00:03:22.480><c> can</c>

00:03:22.630 --> 00:03:22.640 align:start position:0%
we sacrifice space complexity, we can
 

00:03:22.640 --> 00:03:24.470 align:start position:0%
we sacrifice space complexity, we can
actually<00:03:23.040><c> achieve</c><00:03:23.760><c> better</c><00:03:24.080><c> memory</c>

00:03:24.470 --> 00:03:24.480 align:start position:0%
actually achieve better memory
 

00:03:24.480 --> 00:03:26.869 align:start position:0%
actually achieve better memory
complexity.<00:03:25.040><c> And</c><00:03:25.280><c> let</c><00:03:25.440><c> me</c><00:03:25.599><c> show</c><00:03:25.760><c> you</c><00:03:26.000><c> how.</c><00:03:26.640><c> So,</c>

00:03:26.869 --> 00:03:26.879 align:start position:0%
complexity. And let me show you how. So,
 

00:03:26.879 --> 00:03:29.030 align:start position:0%
complexity. And let me show you how. So,
suppose<00:03:27.280><c> we</c><00:03:27.680><c> don't</c><00:03:27.920><c> sort</c><00:03:28.239><c> our</c><00:03:28.400><c> input.</c><00:03:28.879><c> We're</c>

00:03:29.030 --> 00:03:29.040 align:start position:0%
suppose we don't sort our input. We're
 

00:03:29.040 --> 00:03:31.830 align:start position:0%
suppose we don't sort our input. We're
given<00:03:29.280><c> the</c><00:03:29.440><c> default</c><00:03:29.920><c> input.</c><00:03:30.959><c> But</c><00:03:31.200><c> we</c><00:03:31.440><c> use</c>

00:03:31.830 --> 00:03:31.840 align:start position:0%
given the default input. But we use
 

00:03:31.840 --> 00:03:35.110 align:start position:0%
given the default input. But we use
extra<00:03:32.319><c> memory.</c><00:03:33.120><c> We</c><00:03:33.440><c> use</c><00:03:33.680><c> a</c><00:03:33.920><c> hash</c><00:03:34.319><c> set.</c><00:03:34.959><c> But</c>

00:03:35.110 --> 00:03:35.120 align:start position:0%
extra memory. We use a hash set. But
 

00:03:35.120 --> 00:03:37.350 align:start position:0%
extra memory. We use a hash set. But
what<00:03:35.440><c> exactly</c><00:03:35.840><c> is</c><00:03:36.080><c> a</c><00:03:36.239><c> hash</c><00:03:36.560><c> set</c><00:03:36.879><c> going</c><00:03:37.040><c> to</c><00:03:37.200><c> do</c>

00:03:37.350 --> 00:03:37.360 align:start position:0%
what exactly is a hash set going to do
 

00:03:37.360 --> 00:03:40.309 align:start position:0%
what exactly is a hash set going to do
for<00:03:37.599><c> us?</c><00:03:38.080><c> It's</c><00:03:38.319><c> going</c><00:03:38.400><c> to</c><00:03:38.480><c> allow</c><00:03:38.799><c> us</c><00:03:39.200><c> to</c><00:03:39.599><c> insert</c>

00:03:40.309 --> 00:03:40.319 align:start position:0%
for us? It's going to allow us to insert
 

00:03:40.319 --> 00:03:43.030 align:start position:0%
for us? It's going to allow us to insert
elements<00:03:40.879><c> into</c><00:03:41.120><c> the</c><00:03:41.360><c> hash</c><00:03:41.680><c> set</c><00:03:41.920><c> in</c><00:03:42.239><c> big</c><00:03:42.480><c> O</c><00:03:42.720><c> of</c>

00:03:43.030 --> 00:03:43.040 align:start position:0%
elements into the hash set in big O of
 

00:03:43.040 --> 00:03:45.190 align:start position:0%
elements into the hash set in big O of
one<00:03:43.280><c> time.</c><00:03:43.760><c> But</c><00:03:43.920><c> it's</c><00:03:44.239><c> also</c><00:03:44.560><c> going</c><00:03:44.640><c> to</c><00:03:44.799><c> allow</c>

00:03:45.190 --> 00:03:45.200 align:start position:0%
one time. But it's also going to allow
 

00:03:45.200 --> 00:03:48.229 align:start position:0%
one time. But it's also going to allow
us<00:03:45.519><c> to</c><00:03:45.840><c> check.</c><00:03:46.400><c> We</c><00:03:46.640><c> can</c><00:03:46.799><c> ask</c><00:03:47.120><c> our</c><00:03:47.360><c> hashmap,</c>

00:03:48.229 --> 00:03:48.239 align:start position:0%
us to check. We can ask our hashmap,
 

00:03:48.239 --> 00:03:51.110 align:start position:0%
us to check. We can ask our hashmap,
does<00:03:48.799><c> a</c><00:03:49.120><c> certain</c><00:03:49.519><c> value</c><00:03:49.920><c> exist?</c><00:03:50.640><c> We</c><00:03:50.799><c> want</c><00:03:50.959><c> to</c>

00:03:51.110 --> 00:03:51.120 align:start position:0%
does a certain value exist? We want to
 

00:03:51.120 --> 00:03:53.509 align:start position:0%
does a certain value exist? We want to
know,<00:03:51.680><c> does</c><00:03:52.000><c> this</c><00:03:52.319><c> one</c><00:03:52.799><c> exist</c><00:03:53.200><c> in</c><00:03:53.360><c> the</c>

00:03:53.509 --> 00:03:53.519 align:start position:0%
know, does this one exist in the
 

00:03:53.519 --> 00:03:55.110 align:start position:0%
know, does this one exist in the
hashmap?<00:03:54.080><c> Well,</c><00:03:54.239><c> if</c><00:03:54.400><c> we</c><00:03:54.560><c> start</c><00:03:54.720><c> at</c><00:03:54.959><c> the</c>

00:03:55.110 --> 00:03:55.120 align:start position:0%
hashmap? Well, if we start at the
 

00:03:55.120 --> 00:03:57.190 align:start position:0%
hashmap? Well, if we start at the
beginning<00:03:55.280><c> of</c><00:03:55.440><c> the</c><00:03:55.599><c> array,</c><00:03:56.080><c> so</c><00:03:56.319><c> far</c><00:03:56.879><c> nothing</c>

00:03:57.190 --> 00:03:57.200 align:start position:0%
beginning of the array, so far nothing
 

00:03:57.200 --> 00:03:59.429 align:start position:0%
beginning of the array, so far nothing
is<00:03:57.360><c> in</c><00:03:57.519><c> our</c><00:03:57.680><c> hashmap.</c><00:03:58.319><c> So,</c><00:03:58.480><c> a</c><00:03:58.720><c> one</c><00:03:59.040><c> does</c><00:03:59.200><c> not</c>

00:03:59.429 --> 00:03:59.439 align:start position:0%
is in our hashmap. So, a one does not
 

00:03:59.439 --> 00:04:01.270 align:start position:0%
is in our hashmap. So, a one does not
exist<00:03:59.680><c> in</c><00:03:59.840><c> our</c><00:04:00.000><c> hashmap.</c><00:04:00.640><c> That</c><00:04:00.799><c> means</c><00:04:01.040><c> this</c>

00:04:01.270 --> 00:04:01.280 align:start position:0%
exist in our hashmap. That means this
 

00:04:01.280 --> 00:04:03.910 align:start position:0%
exist in our hashmap. That means this
one<00:04:01.599><c> is</c><00:04:01.840><c> not</c><00:04:02.080><c> a</c><00:04:02.319><c> duplicate.</c><00:04:03.280><c> You</c><00:04:03.439><c> can</c><00:04:03.519><c> see</c><00:04:03.680><c> that</c>

00:04:03.910 --> 00:04:03.920 align:start position:0%
one is not a duplicate. You can see that
 

00:04:03.920 --> 00:04:06.470 align:start position:0%
one is not a duplicate. You can see that
this<00:04:04.080><c> is</c><00:04:04.239><c> an</c><00:04:04.480><c> improvement</c><00:04:05.120><c> over</c><00:04:05.760><c> the</c><00:04:06.159><c> brute</c>

00:04:06.470 --> 00:04:06.480 align:start position:0%
this is an improvement over the brute
 

00:04:06.480 --> 00:04:08.949 align:start position:0%
this is an improvement over the brute
force.<00:04:07.120><c> Previously,</c><00:04:07.920><c> to</c><00:04:08.080><c> to</c><00:04:08.400><c> determine</c><00:04:08.720><c> if</c>

00:04:08.949 --> 00:04:08.959 align:start position:0%
force. Previously, to to determine if
 

00:04:08.959 --> 00:04:10.550 align:start position:0%
force. Previously, to to determine if
this<00:04:09.120><c> was</c><00:04:09.200><c> a</c><00:04:09.360><c> duplicate,</c><00:04:09.840><c> we</c><00:04:10.000><c> had</c><00:04:10.159><c> to</c><00:04:10.319><c> check</c>

00:04:10.550 --> 00:04:10.560 align:start position:0%
this was a duplicate, we had to check
 

00:04:10.560 --> 00:04:12.710 align:start position:0%
this was a duplicate, we had to check
every<00:04:10.879><c> other</c><00:04:11.280><c> value</c><00:04:11.599><c> in</c><00:04:11.840><c> the</c><00:04:12.000><c> array.</c><00:04:12.480><c> This</c>

00:04:12.710 --> 00:04:12.720 align:start position:0%
every other value in the array. This
 

00:04:12.720 --> 00:04:14.869 align:start position:0%
every other value in the array. This
time<00:04:12.959><c> we</c><00:04:13.200><c> don't.</c><00:04:13.760><c> But</c><00:04:14.000><c> after</c><00:04:14.239><c> we</c><00:04:14.480><c> have</c><00:04:14.640><c> checked</c>

00:04:14.869 --> 00:04:14.879 align:start position:0%
time we don't. But after we have checked
 

00:04:14.879 --> 00:04:16.949 align:start position:0%
time we don't. But after we have checked
if<00:04:15.120><c> this</c><00:04:15.280><c> is</c><00:04:15.360><c> a</c><00:04:15.519><c> duplicate,</c><00:04:16.079><c> we</c><00:04:16.320><c> do</c><00:04:16.560><c> have</c><00:04:16.720><c> to</c>

00:04:16.949 --> 00:04:16.959 align:start position:0%
if this is a duplicate, we do have to
 

00:04:16.959 --> 00:04:19.509 align:start position:0%
if this is a duplicate, we do have to
add<00:04:17.120><c> it</c><00:04:17.359><c> to</c><00:04:17.519><c> our</c><00:04:17.680><c> hash</c><00:04:18.000><c> set</c><00:04:18.239><c> because</c><00:04:18.799><c> later</c><00:04:19.199><c> on</c>

00:04:19.509 --> 00:04:19.519 align:start position:0%
add it to our hash set because later on
 

00:04:19.519 --> 00:04:22.069 align:start position:0%
add it to our hash set because later on
if<00:04:19.759><c> we</c><00:04:20.000><c> encounter</c><00:04:20.400><c> a</c><00:04:20.639><c> one</c><00:04:21.120><c> like</c><00:04:21.359><c> over</c><00:04:21.600><c> here,</c>

00:04:22.069 --> 00:04:22.079 align:start position:0%
if we encounter a one like over here,
 

00:04:22.079 --> 00:04:23.670 align:start position:0%
if we encounter a one like over here,
then<00:04:22.320><c> we</c><00:04:22.479><c> determine</c><00:04:22.800><c> that</c><00:04:23.040><c> this</c><00:04:23.280><c> is</c><00:04:23.440><c> a</c>

00:04:23.670 --> 00:04:23.680 align:start position:0%
then we determine that this is a
 

00:04:23.680 --> 00:04:25.670 align:start position:0%
then we determine that this is a
duplicate<00:04:24.479><c> because</c><00:04:24.880><c> we</c><00:04:25.040><c> know</c><00:04:25.199><c> that</c><00:04:25.360><c> there's</c>

00:04:25.670 --> 00:04:25.680 align:start position:0%
duplicate because we know that there's
 

00:04:25.680 --> 00:04:28.469 align:start position:0%
duplicate because we know that there's
already<00:04:26.080><c> a</c><00:04:26.320><c> one</c><00:04:26.639><c> in</c><00:04:26.880><c> our</c><00:04:27.040><c> hash</c><00:04:27.440><c> set.</c><00:04:28.000><c> So</c><00:04:28.240><c> next</c>

00:04:28.469 --> 00:04:28.479 align:start position:0%
already a one in our hash set. So next
 

00:04:28.479 --> 00:04:30.310 align:start position:0%
already a one in our hash set. So next
we're<00:04:28.720><c> going</c><00:04:28.720><c> to</c><00:04:28.960><c> check</c><00:04:29.280><c> two.</c><00:04:29.680><c> Two</c><00:04:29.840><c> is</c><00:04:30.000><c> not</c><00:04:30.160><c> a</c>

00:04:30.310 --> 00:04:30.320 align:start position:0%
we're going to check two. Two is not a
 

00:04:30.320 --> 00:04:31.670 align:start position:0%
we're going to check two. Two is not a
duplicate.<00:04:30.720><c> Add</c><00:04:30.880><c> it</c><00:04:31.040><c> here.</c><00:04:31.199><c> Is</c><00:04:31.360><c> three</c><00:04:31.520><c> a</c>

00:04:31.670 --> 00:04:31.680 align:start position:0%
duplicate. Add it here. Is three a
 

00:04:31.680 --> 00:04:33.990 align:start position:0%
duplicate. Add it here. Is three a
duplicate?<00:04:32.080><c> Nope.</c><00:04:32.400><c> Add</c><00:04:32.639><c> it</c><00:04:32.800><c> here.</c><00:04:33.280><c> One.</c><00:04:33.759><c> Is</c>

00:04:33.990 --> 00:04:34.000 align:start position:0%
duplicate? Nope. Add it here. One. Is
 

00:04:34.000 --> 00:04:35.670 align:start position:0%
duplicate? Nope. Add it here. One. Is
this<00:04:34.160><c> a</c><00:04:34.320><c> duplicate?</c><00:04:34.880><c> Yep,</c><00:04:35.120><c> there's</c><00:04:35.280><c> a</c><00:04:35.440><c> one</c>

00:04:35.670 --> 00:04:35.680 align:start position:0%
this a duplicate? Yep, there's a one
 

00:04:35.680 --> 00:04:38.870 align:start position:0%
this a duplicate? Yep, there's a one
over<00:04:35.840><c> here.</c><00:04:36.479><c> So</c><00:04:36.880><c> we</c><00:04:37.199><c> return</c><00:04:37.600><c> true.</c><00:04:38.240><c> This</c><00:04:38.560><c> does</c>

00:04:38.870 --> 00:04:38.880 align:start position:0%
over here. So we return true. This does
 

00:04:38.880 --> 00:04:41.510 align:start position:0%
over here. So we return true. This does
contain<00:04:39.360><c> duplicates.</c><00:04:40.400><c> And</c><00:04:40.639><c> by</c><00:04:40.880><c> the</c><00:04:41.040><c> way,</c>

00:04:41.510 --> 00:04:41.520 align:start position:0%
contain duplicates. And by the way,
 

00:04:41.520 --> 00:04:44.150 align:start position:0%
contain duplicates. And by the way,
since<00:04:42.160><c> each</c><00:04:42.479><c> operation</c><00:04:43.040><c> was</c><00:04:43.360><c> just</c><00:04:43.600><c> big</c><00:04:43.840><c> O</c><00:04:44.000><c> of</c>

00:04:44.150 --> 00:04:44.160 align:start position:0%
since each operation was just big O of
 

00:04:44.160 --> 00:04:45.990 align:start position:0%
since each operation was just big O of
one,<00:04:44.479><c> we</c><00:04:44.639><c> had</c><00:04:44.800><c> to</c><00:04:44.960><c> do</c><00:04:45.040><c> that</c><00:04:45.199><c> for</c><00:04:45.360><c> every</c><00:04:45.680><c> value</c>

00:04:45.990 --> 00:04:46.000 align:start position:0%
one, we had to do that for every value
 

00:04:46.000 --> 00:04:47.990 align:start position:0%
one, we had to do that for every value
in<00:04:46.240><c> the</c><00:04:46.479><c> input</c><00:04:46.800><c> array.</c><00:04:47.199><c> And</c><00:04:47.360><c> we</c><00:04:47.520><c> only</c><00:04:47.680><c> had</c><00:04:47.840><c> to</c>

00:04:47.990 --> 00:04:48.000 align:start position:0%
in the input array. And we only had to
 

00:04:48.000 --> 00:04:50.230 align:start position:0%
in the input array. And we only had to
scan<00:04:48.320><c> through</c><00:04:48.560><c> the</c><00:04:48.720><c> list</c><00:04:48.960><c> of</c><00:04:49.120><c> inputs</c><00:04:49.600><c> once.</c>

00:04:50.230 --> 00:04:50.240 align:start position:0%
scan through the list of inputs once.
 

00:04:50.240 --> 00:04:52.710 align:start position:0%
scan through the list of inputs once.
The<00:04:50.479><c> time</c><00:04:50.720><c> complexity</c><00:04:51.440><c> is</c><00:04:51.680><c> going</c><00:04:51.840><c> to</c><00:04:51.919><c> be</c><00:04:52.080><c> big</c><00:04:52.479><c> O</c>

00:04:52.710 --> 00:04:52.720 align:start position:0%
The time complexity is going to be big O
 

00:04:52.720 --> 00:04:55.110 align:start position:0%
The time complexity is going to be big O
of<00:04:52.960><c> N.</c><00:04:53.440><c> But</c><00:04:53.600><c> the</c><00:04:53.759><c> space</c><00:04:54.080><c> complexity,</c><00:04:54.720><c> we</c><00:04:54.960><c> did</c>

00:04:55.110 --> 00:04:55.120 align:start position:0%
of N. But the space complexity, we did
 

00:04:55.120 --> 00:04:56.950 align:start position:0%
of N. But the space complexity, we did
have<00:04:55.280><c> to</c><00:04:55.440><c> sacrifice</c><00:04:55.919><c> a</c><00:04:56.160><c> little</c><00:04:56.240><c> bit.</c><00:04:56.639><c> We</c><00:04:56.800><c> have</c>

00:04:56.950 --> 00:04:56.960 align:start position:0%
have to sacrifice a little bit. We have
 

00:04:56.960 --> 00:04:59.350 align:start position:0%
have to sacrifice a little bit. We have
to<00:04:57.120><c> create</c><00:04:57.360><c> a</c><00:04:57.520><c> hash</c><00:04:57.919><c> set</c><00:04:58.160><c> and</c><00:04:58.400><c> the</c><00:04:58.800><c> memory</c><00:04:59.199><c> that</c>

00:04:59.350 --> 00:04:59.360 align:start position:0%
to create a hash set and the memory that
 

00:04:59.360 --> 00:05:01.830 align:start position:0%
to create a hash set and the memory that
that<00:04:59.520><c> hash</c><00:04:59.840><c> set</c><00:05:00.080><c> will</c><00:05:00.320><c> use</c><00:05:00.720><c> could</c><00:05:00.960><c> be</c><00:05:01.199><c> up</c><00:05:01.440><c> to</c>

00:05:01.830 --> 00:05:01.840 align:start position:0%
that hash set will use could be up to
 

00:05:01.840 --> 00:05:04.710 align:start position:0%
that hash set will use could be up to
the<00:05:02.160><c> size</c><00:05:02.560><c> of</c><00:05:02.800><c> the</c><00:05:03.040><c> input</c><00:05:03.440><c> array,</c><00:05:03.759><c> which</c><00:05:03.919><c> is</c><00:05:04.160><c> n.</c>

00:05:04.710 --> 00:05:04.720 align:start position:0%
the size of the input array, which is n.
 

00:05:04.720 --> 00:05:07.590 align:start position:0%
the size of the input array, which is n.
So<00:05:04.960><c> we</c><00:05:05.199><c> do</c><00:05:05.520><c> end</c><00:05:05.759><c> up</c><00:05:05.919><c> using</c><00:05:06.240><c> extra</c><00:05:06.639><c> memory,</c><00:05:07.360><c> but</c>

00:05:07.590 --> 00:05:07.600 align:start position:0%
So we do end up using extra memory, but
 

00:05:07.600 --> 00:05:09.189 align:start position:0%
So we do end up using extra memory, but
that's<00:05:07.840><c> not</c><00:05:08.000><c> too</c><00:05:08.160><c> bad.</c><00:05:08.479><c> This</c><00:05:08.639><c> is</c><00:05:08.800><c> about</c><00:05:08.960><c> as</c>

00:05:09.189 --> 00:05:09.199 align:start position:0%
that's not too bad. This is about as
 

00:05:09.199 --> 00:05:11.110 align:start position:0%
that's not too bad. This is about as
efficient<00:05:09.600><c> as</c><00:05:09.759><c> we</c><00:05:09.919><c> can</c><00:05:10.080><c> get</c><00:05:10.320><c> in</c><00:05:10.479><c> terms</c><00:05:10.639><c> of</c><00:05:10.800><c> time</c>

00:05:11.110 --> 00:05:11.120 align:start position:0%
efficient as we can get in terms of time
 

00:05:11.120 --> 00:05:13.270 align:start position:0%
efficient as we can get in terms of time
complexity.<00:05:11.919><c> So</c><00:05:12.080><c> let's</c><00:05:12.320><c> get</c><00:05:12.479><c> into</c><00:05:12.720><c> the</c><00:05:12.960><c> code</c>

00:05:13.270 --> 00:05:13.280 align:start position:0%
complexity. So let's get into the code
 

00:05:13.280 --> 00:05:15.270 align:start position:0%
complexity. So let's get into the code
now.<00:05:13.919><c> Okay.</c><00:05:14.160><c> So</c><00:05:14.400><c> now</c><00:05:14.560><c> let's</c><00:05:14.800><c> get</c><00:05:14.880><c> into</c><00:05:15.120><c> the</c>

00:05:15.270 --> 00:05:15.280 align:start position:0%
now. Okay. So now let's get into the
 

00:05:15.280 --> 00:05:16.629 align:start position:0%
now. Okay. So now let's get into the
code.<00:05:15.520><c> So</c><00:05:15.680><c> the</c><00:05:15.919><c> first</c><00:05:16.000><c> thing</c><00:05:16.160><c> I'm</c><00:05:16.320><c> going</c><00:05:16.400><c> to</c><00:05:16.479><c> do</c>

00:05:16.629 --> 00:05:16.639 align:start position:0%
code. So the first thing I'm going to do
 

00:05:16.639 --> 00:05:19.590 align:start position:0%
code. So the first thing I'm going to do
is<00:05:17.039><c> create</c><00:05:17.440><c> that</c><00:05:17.680><c> hash</c><00:05:18.160><c> set.</c><00:05:18.560><c> In</c><00:05:18.800><c> Python</c><00:05:19.360><c> you</c>

00:05:19.590 --> 00:05:19.600 align:start position:0%
is create that hash set. In Python you
 

00:05:19.600 --> 00:05:21.830 align:start position:0%
is create that hash set. In Python you
can<00:05:19.759><c> do</c><00:05:19.919><c> that</c><00:05:20.400><c> just</c><00:05:20.720><c> like</c><00:05:20.960><c> this.</c><00:05:21.440><c> It's</c><00:05:21.680><c> just</c>

00:05:21.830 --> 00:05:21.840 align:start position:0%
can do that just like this. It's just
 

00:05:21.840 --> 00:05:24.870 align:start position:0%
can do that just like this. It's just
called<00:05:22.080><c> a</c><00:05:22.320><c> set.</c><00:05:23.039><c> And</c><00:05:23.440><c> then</c><00:05:24.000><c> the</c><00:05:24.400><c> simple</c><00:05:24.720><c> thing</c>

00:05:24.870 --> 00:05:24.880 align:start position:0%
called a set. And then the simple thing
 

00:05:24.880 --> 00:05:27.909 align:start position:0%
called a set. And then the simple thing
is<00:05:25.280><c> just</c><00:05:25.680><c> going</c><00:05:26.000><c> through</c><00:05:26.479><c> every</c><00:05:26.880><c> value</c><00:05:27.360><c> in</c><00:05:27.680><c> the</c>

00:05:27.909 --> 00:05:27.919 align:start position:0%
is just going through every value in the
 

00:05:27.919 --> 00:05:31.430 align:start position:0%
is just going through every value in the
input<00:05:28.320><c> array</c><00:05:28.800><c> nums.</c><00:05:29.680><c> And</c><00:05:30.400><c> uh</c><00:05:30.560><c> before</c><00:05:30.880><c> we</c><00:05:31.199><c> end</c>

00:05:31.430 --> 00:05:31.440 align:start position:0%
input array nums. And uh before we end
 

00:05:31.440 --> 00:05:33.430 align:start position:0%
input array nums. And uh before we end
up<00:05:31.600><c> adding</c><00:05:31.919><c> it</c><00:05:32.080><c> to</c><00:05:32.320><c> our</c><00:05:32.479><c> hash</c><00:05:32.800><c> set</c><00:05:33.199><c> because</c>

00:05:33.430 --> 00:05:33.440 align:start position:0%
up adding it to our hash set because
 

00:05:33.440 --> 00:05:35.430 align:start position:0%
up adding it to our hash set because
remember<00:05:33.759><c> we</c><00:05:34.000><c> want</c><00:05:34.160><c> to</c><00:05:34.479><c> add</c><00:05:34.800><c> every</c><00:05:35.120><c> one</c><00:05:35.360><c> of</c>

00:05:35.430 --> 00:05:35.440 align:start position:0%
remember we want to add every one of
 

00:05:35.440 --> 00:05:37.430 align:start position:0%
remember we want to add every one of
these<00:05:35.680><c> values</c><00:05:36.080><c> to</c><00:05:36.240><c> our</c><00:05:36.400><c> hash</c><00:05:36.800><c> set</c><00:05:37.039><c> just</c><00:05:37.280><c> like</c>

00:05:37.430 --> 00:05:37.440 align:start position:0%
these values to our hash set just like
 

00:05:37.440 --> 00:05:39.749 align:start position:0%
these values to our hash set just like
this.<00:05:37.919><c> But</c><00:05:38.160><c> before</c><00:05:38.479><c> we</c><00:05:38.720><c> even</c><00:05:39.039><c> do</c><00:05:39.199><c> that,</c><00:05:39.520><c> we</c>

00:05:39.749 --> 00:05:39.759 align:start position:0%
this. But before we even do that, we
 

00:05:39.759 --> 00:05:43.270 align:start position:0%
this. But before we even do that, we
want<00:05:39.919><c> to</c><00:05:40.080><c> know</c><00:05:40.720><c> is</c><00:05:41.199><c> n</c><00:05:41.600><c> a</c><00:05:41.919><c> duplicate.</c><00:05:42.720><c> Does</c><00:05:42.960><c> this</c>

00:05:43.270 --> 00:05:43.280 align:start position:0%
want to know is n a duplicate. Does this
 

00:05:43.280 --> 00:05:46.310 align:start position:0%
want to know is n a duplicate. Does this
value<00:05:43.840><c> already</c><00:05:44.560><c> exist</c><00:05:45.039><c> in</c><00:05:45.280><c> our</c><00:05:45.440><c> hash</c><00:05:45.840><c> set?</c><00:05:46.160><c> And</c>

00:05:46.310 --> 00:05:46.320 align:start position:0%
value already exist in our hash set? And
 

00:05:46.320 --> 00:05:49.510 align:start position:0%
value already exist in our hash set? And
if<00:05:46.479><c> it</c><00:05:46.720><c> does,</c><00:05:47.280><c> we</c><00:05:47.520><c> know</c><00:05:47.759><c> that</c><00:05:48.400><c> our</c><00:05:49.039><c> array</c>

00:05:49.510 --> 00:05:49.520 align:start position:0%
if it does, we know that our array
 

00:05:49.520 --> 00:05:51.590 align:start position:0%
if it does, we know that our array
contains<00:05:50.080><c> duplicates.</c><00:05:50.800><c> So</c><00:05:51.039><c> we</c><00:05:51.280><c> don't</c><00:05:51.440><c> even</c>

00:05:51.590 --> 00:05:51.600 align:start position:0%
contains duplicates. So we don't even
 

00:05:51.600 --> 00:05:53.189 align:start position:0%
contains duplicates. So we don't even
have<00:05:51.759><c> to</c><00:05:51.919><c> continue</c><00:05:52.320><c> through</c><00:05:52.560><c> the</c><00:05:52.720><c> rest</c><00:05:52.880><c> of</c><00:05:52.960><c> the</c>

00:05:53.189 --> 00:05:53.199 align:start position:0%
have to continue through the rest of the
 

00:05:53.199 --> 00:05:55.430 align:start position:0%
have to continue through the rest of the
array,<00:05:53.600><c> we</c><00:05:53.759><c> can</c><00:05:54.000><c> immediately</c><00:05:54.639><c> return</c><00:05:55.039><c> true</c>

00:05:55.430 --> 00:05:55.440 align:start position:0%
array, we can immediately return true
 

00:05:55.440 --> 00:05:57.830 align:start position:0%
array, we can immediately return true
because<00:05:55.680><c> we</c><00:05:55.919><c> found</c><00:05:56.240><c> a</c><00:05:56.560><c> duplicate.</c><00:05:57.280><c> But</c><00:05:57.440><c> if</c><00:05:57.600><c> it</c>

00:05:57.830 --> 00:05:57.840 align:start position:0%
because we found a duplicate. But if it
 

00:05:57.840 --> 00:05:59.510 align:start position:0%
because we found a duplicate. But if it
doesn't<00:05:58.160><c> contain</c><00:05:58.400><c> a</c><00:05:58.639><c> duplicate,</c><00:05:59.280><c> we're</c><00:05:59.440><c> going</c>

00:05:59.510 --> 00:05:59.520 align:start position:0%
doesn't contain a duplicate, we're going
 

00:05:59.520 --> 00:06:01.670 align:start position:0%
doesn't contain a duplicate, we're going
to<00:05:59.680><c> add</c><00:05:59.919><c> that</c><00:06:00.160><c> value.</c><00:06:00.720><c> Then</c><00:06:00.960><c> iterate</c><00:06:01.440><c> through</c>

00:06:01.670 --> 00:06:01.680 align:start position:0%
to add that value. Then iterate through
 

00:06:01.680 --> 00:06:04.390 align:start position:0%
to add that value. Then iterate through
the<00:06:01.840><c> rest</c><00:06:02.080><c> of</c><00:06:02.160><c> the</c><00:06:02.400><c> array</c><00:06:03.039><c> of</c><00:06:03.280><c> nums.</c><00:06:04.000><c> And</c><00:06:04.160><c> then</c>

00:06:04.390 --> 00:06:04.400 align:start position:0%
the rest of the array of nums. And then
 

00:06:04.400 --> 00:06:06.550 align:start position:0%
the rest of the array of nums. And then
the<00:06:04.720><c> loop</c><00:06:05.039><c> will</c><00:06:05.280><c> exit.</c><00:06:05.840><c> And</c><00:06:06.000><c> then</c><00:06:06.240><c> we</c><00:06:06.400><c> can</c>

00:06:06.550 --> 00:06:06.560 align:start position:0%
the loop will exit. And then we can
 

00:06:06.560 --> 00:06:09.270 align:start position:0%
the loop will exit. And then we can
return<00:06:06.960><c> false</c><00:06:07.440><c> to</c><00:06:07.759><c> indicate</c><00:06:08.080><c> that</c><00:06:08.400><c> we</c><00:06:08.639><c> did</c><00:06:08.880><c> not</c>

00:06:09.270 --> 00:06:09.280 align:start position:0%
return false to indicate that we did not
 

00:06:09.280 --> 00:06:11.909 align:start position:0%
return false to indicate that we did not
find<00:06:09.759><c> any</c><00:06:10.160><c> duplicates</c><00:06:10.800><c> in</c><00:06:11.039><c> the</c><00:06:11.199><c> array.</c><00:06:11.680><c> Now,</c>

00:06:11.909 --> 00:06:11.919 align:start position:0%
find any duplicates in the array. Now,
 

00:06:11.919 --> 00:06:13.749 align:start position:0%
find any duplicates in the array. Now,
let's<00:06:12.240><c> run</c><00:06:12.400><c> the</c><00:06:12.639><c> code</c><00:06:12.880><c> to</c><00:06:13.039><c> make</c><00:06:13.199><c> sure</c><00:06:13.280><c> that</c><00:06:13.520><c> it</c>

00:06:13.749 --> 00:06:13.759 align:start position:0%
let's run the code to make sure that it
 

00:06:13.759 --> 00:06:15.909 align:start position:0%
let's run the code to make sure that it
works.<00:06:14.400><c> And</c><00:06:14.639><c> on</c><00:06:14.800><c> the</c><00:06:14.960><c> left,</c><00:06:15.199><c> you</c><00:06:15.440><c> can</c><00:06:15.520><c> see</c><00:06:15.680><c> that</c>

00:06:15.909 --> 00:06:15.919 align:start position:0%
works. And on the left, you can see that
 

00:06:15.919 --> 00:06:17.830 align:start position:0%
works. And on the left, you can see that
yes,<00:06:16.160><c> it</c><00:06:16.400><c> does</c><00:06:16.560><c> work.</c><00:06:16.800><c> And</c><00:06:16.960><c> it</c><00:06:17.199><c> is</c><00:06:17.360><c> about</c><00:06:17.600><c> as</c>

00:06:17.830 --> 00:06:17.840 align:start position:0%
yes, it does work. And it is about as
 

00:06:17.840 --> 00:06:19.590 align:start position:0%
yes, it does work. And it is about as
efficient<00:06:18.240><c> as</c><00:06:18.400><c> we</c><00:06:18.560><c> can</c><00:06:18.720><c> get.</c><00:06:19.039><c> So,</c><00:06:19.199><c> I</c><00:06:19.440><c> really</c>

00:06:19.590 --> 00:06:19.600 align:start position:0%
efficient as we can get. So, I really
 

00:06:19.600 --> 00:06:21.909 align:start position:0%
efficient as we can get. So, I really
hope<00:06:19.759><c> that</c><00:06:20.000><c> this</c><00:06:20.160><c> was</c><00:06:20.400><c> helpful.</c><00:06:20.960><c> If</c><00:06:21.120><c> it</c><00:06:21.280><c> was,</c>

00:06:21.909 --> 00:06:21.919 align:start position:0%
hope that this was helpful. If it was,
 

00:06:21.919 --> 00:06:23.670 align:start position:0%
hope that this was helpful. If it was,
please<00:06:22.160><c> like</c><00:06:22.400><c> and</c><00:06:22.639><c> subscribe.</c><00:06:23.120><c> It</c><00:06:23.360><c> supports</c>

00:06:23.670 --> 00:06:23.680 align:start position:0%
please like and subscribe. It supports
 

00:06:23.680 --> 00:06:25.430 align:start position:0%
please like and subscribe. It supports
the<00:06:23.919><c> channel</c><00:06:24.160><c> a</c><00:06:24.400><c> lot.</c><00:06:24.720><c> consider</c><00:06:25.039><c> checking</c><00:06:25.360><c> out</c>

00:06:25.430 --> 00:06:25.440 align:start position:0%
the channel a lot. consider checking out
 

00:06:25.440 --> 00:06:27.029 align:start position:0%
the channel a lot. consider checking out
my<00:06:25.680><c> Patreon</c><00:06:26.080><c> where</c><00:06:26.240><c> you</c><00:06:26.400><c> can</c><00:06:26.479><c> further</c><00:06:26.800><c> support</c>

00:06:27.029 --> 00:06:27.039 align:start position:0%
my Patreon where you can further support
 

00:06:27.039 --> 00:06:28.950 align:start position:0%
my Patreon where you can further support
the<00:06:27.280><c> channel</c><00:06:27.520><c> and</c><00:06:27.840><c> hopefully</c><00:06:28.319><c> I'll</c><00:06:28.639><c> see</c><00:06:28.800><c> you</c>

00:06:28.950 --> 00:06:28.960 align:start position:0%
the channel and hopefully I'll see you
 

00:06:28.960 --> 00:06:31.520 align:start position:0%
the channel and hopefully I'll see you
pretty<00:06:29.199><c> soon.</c>

